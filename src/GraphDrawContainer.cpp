/*
* ============================================================================
*  Name     : CGraphDrawContainer from GraphDrawContainer.h
*  Part of  : GraphDraw
*  Created  : 3/7/2003 by Makidis Michael
*  Implementation notes:
*     Initial content was generated by Series 60 AppWizard.
*  Copyright: Makidis Michael 2003-2004
* ============================================================================
*/

// INCLUDE FILES
#include "GraphDrawContainer.h"
#include <GRAPHDRAW.RSG>
#include <aknnotewrappers.h> // for note
#include <stringloader.h>  // for StringLoader

// ================= MEMBER FUNCTIONS =======================

CGraphDrawContainer::CGraphDrawContainer(CGraphDrawDocument *aDocument, CGraphDrawView *aView)
:	iMoving (EFalse), iZooming(EFalse), iDocument(aDocument), iView(aView)
{

}

// ---------------------------------------------------------
// CGraphDrawContainer::ConstructL(const TRect& aRect)
// EPOC two phased constructor
// ---------------------------------------------------------
//
void CGraphDrawContainer::ConstructL(const TRect& aRect)
    {
	HBufC* textResource = StringLoader::LoadLC(R_GRAPHDRAW_MOVING);
	iMovingText = *textResource;
	CleanupStack::PopAndDestroy(textResource);

	textResource = StringLoader::LoadLC(R_GRAPHDRAW_ZOOMING);
	iZoomingText = *textResource;
	CleanupStack::PopAndDestroy(textResource);

    CreateWindowL();
    SetRect(aRect);
    ActivateL();
    }

// Destructor
CGraphDrawContainer::~CGraphDrawContainer()
    {
    }

// ---------------------------------------------------------
// CGraphDrawContainer::SizeChanged()
// Called by framework when the view size is changed
// ---------------------------------------------------------
//
void CGraphDrawContainer::SizeChanged()
    {
    // TODO: Add here control resize code etc.
    }

// ---------------------------------------------------------
// CGraphDrawContainer::CountComponentControls() const
// ---------------------------------------------------------
//
TInt CGraphDrawContainer::CountComponentControls() const
    {
    return 0; // return nbr of controls inside this container
    }

// ---------------------------------------------------------
// CGraphDrawContainer::ComponentControl(TInt aIndex) const
// ---------------------------------------------------------
//
CCoeControl* CGraphDrawContainer::ComponentControl(TInt /*aIndex*/) const
    {
	return NULL;
    }

// ---------------------------------------------------------
// CGraphDrawContainer::Draw(const TRect& aRect) const
// ---------------------------------------------------------
//
void CGraphDrawContainer::Draw(const TRect& aRect) const
    {
    CWindowGc& gc = SystemGc();
	gc.Clear();

	if(!iDocument->iCenterSet)
	{
		iDocument->iCenter = aRect.Center();
		iDocument->iCenterSet = ETrue;
	}

	// Draw x & y axis
	gc.SetPenSize(TSize(1,1));
    gc.SetPenColor(KRgbBlack);
	gc.SetPenStyle(CGraphicsContext::EDashedPen);

	TPoint startPoint(iDocument->iCenter.iX, 0);
	TPoint endPoint(iDocument->iCenter.iX, aRect.Height());
	gc.DrawLine(startPoint,endPoint);

	startPoint.SetXY(0, aRect.Height() - iDocument->iCenter.iY-1);
	endPoint.SetXY(aRect.Width(), aRect.Height() - iDocument->iCenter.iY-1);
	gc.DrawLine(startPoint,endPoint);

	// Calculate zoom factor
	TReal zoomFactor = iDocument->iZoom/1000.0;

	// Draw all the graph points
	gc.SetPenStyle(CGraphicsContext::ESolidPen);
	for(TUint currentFunction = 0; currentFunction < FUNCTIONS;
		currentFunction++)
		{
		// select colour
		switch(currentFunction)
		{
			case 0:
				gc.SetPenColor(KRgbRed);
				break;
			case 1:
				gc.SetPenColor(KRgbBlue);
				break;
			case 2:
				gc.SetPenColor(KRgbGreen);
				break;
			case 3:
				gc.SetPenColor(KRgbYellow);
				break;
		}
		// draw the points
		TInt X; TInt Y; TBool error = ETrue;
		for(X = 0; X < aRect.Width(); X++)
		{
			if (iDocument->GetYL((X - iDocument->iCenter.iX)/zoomFactor, Y, currentFunction) == 0)
				{
				if (error)
					{
					startPoint.SetXY(X, (aRect.Height() - iDocument->iCenter.iY-1) - Y);
					gc.Plot(startPoint);
					}
				else
					{	
					endPoint.SetXY(X, (aRect.Height() - iDocument->iCenter.iY-1) - Y);
					gc.DrawLine (startPoint, endPoint);
					startPoint = endPoint;
					}
				error = EFalse;
				}
			else
				{
				error = ETrue;
				}
		} // for
	}//for

	if(iMoving || iZooming)
	{
		// Draw the indicators

		gc.SetPenColor(KRgbDarkBlue);

		const TInt distanceFromCenter = 40;
		const TInt triangleHeight = 5;
		const TInt triangleWidth = 5;

		// Text

		const CFont* fontUsed = iEikonEnv->AnnotationFont();
		gc.UseFont(fontUsed);

		TRect box(aRect.Center().iX-distanceFromCenter,	aRect.Center().iY-distanceFromCenter,
			aRect.Center().iX+distanceFromCenter, aRect.Center().iY+distanceFromCenter);
		TInt baseline = box.Height() /2 + fontUsed->AscentInPixels()/2 -2;

		if(iMoving)
			gc.DrawText(iMovingText, box, baseline, CGraphicsContext::ECenter);
		else
			gc.DrawText(iZoomingText, box, baseline, CGraphicsContext::ECenter);

		// Triangles

		CArrayFixFlat<TPoint> *pointList = new(ELeave)CArrayFixFlat<TPoint>(3);
		CleanupStack::PushL(pointList);
		TPoint point1, point2, point3;
		
		gc.SetBrushColor(KRgbDarkBlue);
		gc.SetBrushStyle(CGraphicsContext::ESolidBrush);

		// 1st triangle
		point1.SetXY(aRect.Center().iX-triangleWidth, aRect.Center().iY-distanceFromCenter);
		point2.SetXY(aRect.Center().iX+triangleWidth, aRect.Center().iY-distanceFromCenter);
		point3.SetXY(aRect.Center().iX, aRect.Center().iY-distanceFromCenter-triangleHeight);
		pointList->AppendL(point1);
		pointList->AppendL(point2);
		pointList->AppendL(point3);

		gc.DrawPolygon(pointList);

		pointList->Reset();

		// 2nd triangle
		point1.SetXY(aRect.Center().iX-triangleWidth, aRect.Center().iY+distanceFromCenter);
		point2.SetXY(aRect.Center().iX+triangleWidth, aRect.Center().iY+distanceFromCenter);
		point3.SetXY(aRect.Center().iX, aRect.Center().iY+distanceFromCenter+triangleHeight);
		pointList->AppendL(point1);
		pointList->AppendL(point2);
		pointList->AppendL(point3);

		gc.DrawPolygon(pointList);

		pointList->Reset();

		if(iMoving)
		{
			// 3rd triangle
			point1.SetXY(aRect.Center().iX+distanceFromCenter, aRect.Center().iY-triangleWidth-1);
			point2.SetXY(aRect.Center().iX+distanceFromCenter, aRect.Center().iY+triangleWidth-1);
			point3.SetXY(aRect.Center().iX+distanceFromCenter+triangleHeight, aRect.Center().iY-1);
			pointList->AppendL(point1);
			pointList->AppendL(point2);
			pointList->AppendL(point3);

			gc.DrawPolygon(pointList);

			pointList->Reset();

			// 4th triangle
			point1.SetXY(aRect.Center().iX-distanceFromCenter, aRect.Center().iY-triangleWidth-1);
			point2.SetXY(aRect.Center().iX-distanceFromCenter, aRect.Center().iY+triangleWidth-1);
			point3.SetXY(aRect.Center().iX-distanceFromCenter-triangleHeight, aRect.Center().iY-1);
			pointList->AppendL(point1);
			pointList->AppendL(point2);
			pointList->AppendL(point3);

			gc.DrawPolygon(pointList);

			pointList->Reset();
		}

		CleanupStack::PopAndDestroy(pointList);
	}
    
    }

// ----------------------------------------------------------------------------
// TKeyResponse CGraphDrawContainer::OfferKeyEventL( const TKeyEvent&,
//  TEventCode )
// Handles the key events.
// ----------------------------------------------------------------------------
//
TKeyResponse CGraphDrawContainer::OfferKeyEventL(
    const TKeyEvent& aKeyEvent,
    TEventCode aType )
    {
    if ( aType != EEventKey ) // Is not key event?
        {
        return EKeyWasNotConsumed;
        }

    switch ( aKeyEvent.iCode ) // The code of key event is...
        {
		case EKeyEnter:
		case EKeyOK:
            {
            iMoving = !iMoving;
			iZooming = EFalse;
			DrawNow();
			return EKeyWasConsumed;
            break;
            }
		case EKeyLeftArrow:
			{
			if(iMoving)
				{
				iView->HandleCommandL(EGraphDrawMoveCenterLeft);
				DrawNow();
				return EKeyWasConsumed;
				}
			else 
				return EKeyWasNotConsumed;
			break;
			}
		case EKeyRightArrow:
			{
			if(iMoving)
				{
				iView->HandleCommandL(EGraphDrawMoveCenterRight);
				DrawNow();
				return EKeyWasConsumed;
				}
			else
				return EKeyWasNotConsumed;
			break;
			}
		case EKeyUpArrow:
			{
			if(iMoving)
				{
				iView->HandleCommandL(EGraphDrawMoveCenterUp);
				DrawNow();
				return EKeyWasConsumed;
				}
			else if(iZooming)
			{
				iView->HandleCommandL(EGraphDrawZoomIn);
				DrawNow();
				return EKeyWasConsumed;
			}
			else
				return EKeyWasNotConsumed;
			break;
			}
		case EKeyDownArrow:
			{
			if(iMoving)
				{
				iView->HandleCommandL(EGraphDrawMoveCenterDown);
				DrawNow();
				return EKeyWasConsumed;
				}
			else if(iZooming)
			{
				iView->HandleCommandL(EGraphDrawZoomOut);
				DrawNow();
				return EKeyWasConsumed;
			}
			else
				return EKeyWasNotConsumed;
			break;
			}
        default:
			return EKeyWasNotConsumed;
        }
    }

// ---------------------------------------------------------
// CGraphDrawContainer::HandleControlEventL(
//     CCoeControl* aControl,TCoeEvent aEventType)
// ---------------------------------------------------------
//
void CGraphDrawContainer::HandleControlEventL(
    CCoeControl* /*aControl*/,TCoeEvent /*aEventType*/)
    {
    // TODO: Add your control event handler code here
    }

// End of File  

